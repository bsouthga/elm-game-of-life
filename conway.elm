
-- Conway's game of life
-- -----------------------------------
-- adapted algorithms from Haskell
-- implementation here http://pastebin.com/K3DCyKj3


import List exposing (map, length, member, filter, concat)
import Graphics.Element exposing (Element, show, container, middle, flow, down)
import Graphics.Collage exposing (collage, move, square, filled, Form, rect, outlined, solid)
import Color exposing (lightBlue, lightGray)
import Basics exposing (toFloat, round)
import Signal exposing ((<~), (~), foldp)
import Time exposing (every, second, Time)
import Window


-- Convenience Type Aliases
type alias Cell = (Float, Float)
type alias Board = List Cell
type alias Overlay = List Form


-- board configuration
height = 50
width = 50
cellSize = 5
activeColor = lightBlue
fps = 1


-- check if a cell is in the board (element member of list)
-- flip arguments for currying
alive : Board -> Cell -> Bool
alive b c = member c b


-- check if a cell is not in the board
dead : Board -> Cell -> Bool
dead b c = not <| alive b c


-- get list of neighbor coordinates, bounded by board dimensions --
neighbors : Cell -> Board
neighbors (x, y) =
  map wrap
    [
       (x-1,y-1) , (x  ,y-1)  , (x+1,y-1)
    ,  (x-1,y  ) , {- (x,y) -}  (x+1,y  )
    ,  (x-1,y+1) , (x  ,y+1)  , (x+1,y+1)
    ]


-- wrap a cells coordinates around the edge of the board
wrap : Cell -> Cell
wrap (x, y) =
  (
    toFloat ( ((round (x - 1)) % (round width)) + 1)
  , toFloat ( ((round (y - 1)) % (round height) + 1))
  )


-- Count the number of living neighbors in a cell
livingNeighbors : Board -> Cell -> Int
livingNeighbors b c =
  neighbors c
    |> filter (alive b)
    |> length


-- Evolution Rules
shouldSurvive : Board -> Cell -> Bool
shouldSurvive b c =
  let n = livingNeighbors b c
  in case n of
    2 -> True
    3 -> True
    _ -> False

shouldBeBorn : Board -> Cell -> Bool
shouldBeBorn b c = (dead b c) && (livingNeighbors b c == 3)


-- filter board by rules
survivors : Board -> Board
survivors b = filter ( shouldSurvive b ) b

births : Board -> Board
births b =
  map neighbors b
    |> concat
    |> removeDuplicates
    |> filter ( shouldBeBorn b )


-- remove duplicate cells generated by finding neighbors
removeDuplicates : Board -> Board
removeDuplicates b =
  case b of
    [] -> []
    x :: xs -> x :: removeDuplicates (filter ((/=) x) xs)


-- evolve state of game
evolve : Board -> Board
evolve b = survivors b ++ births b



renderCell : Cell -> Form
renderCell (x,y) =
  square cellSize
    |> filled activeColor
    |> move
        (
          (x - width/2)*cellSize
        , (y - height/2)*cellSize
        )

-- one big rectangle for background
background : Form
background =
  rect (width*cellSize) (height*cellSize)
    |> filled lightGray


render : Board -> Element
render b =
  background :: map renderCell b
    |> collage (round (cellSize*width)) (round (cellSize*height))


-- run the game
main : Signal Element
main = view <~ Window.dimensions ~ foldp step start (every (second/fps))


-- one step of the game
step : Time -> Board -> Board
step t past = evolve past


-- starting signal for evolution
start : Board
start = map (\x -> (x, 25)) [20..30]


-- Convert board to displayable element
view : (Int,Int) -> Board -> Element
view (w,h) board =
  container w h middle
    <| flow down
        [
          show "conway.elm"
        , render board
        ]


-- create a glider centered at a given cell
glider : Cell -> Board
glider (x, y) =
  map wrap
    [
      {-----}    {-----}    (x+1, y-1)
      ,(x-1, y) {-(x, y)-} ,(x+1, y)
      {-----}  ,(x, y+1)   ,(x+1, y+1)
    ]
