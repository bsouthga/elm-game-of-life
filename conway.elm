
-- Conway's game of life
-- -----------------------------------
-- adapted algorithms from Haskell
-- implementation here http://pastebin.com/K3DCyKj3


import List exposing (map, length, member, filter, concat)
import Graphics.Element exposing (Element, show, container, middle)
import Graphics.Collage exposing (collage, move, square, filled, Form)
import Time exposing (second, every, Time)
import Task exposing (sleep, Task, andThen)
import TaskTutorial exposing (print)
import Color exposing (blue, gray)
import Basics exposing (toFloat, round)
import Window


type alias Overlay = List Form
type alias Board = List Cell
type alias Cell = (Float, Float)



-- board dimensions
height : Float
height = 100

width : Float
width = 100

cellSize : Float
cellSize = 4


-- check if a cell is in the board (element member of list)
-- flip arguments for currying
alive : Board -> Cell -> Bool
alive b c = member c b


-- check if a cell is not in the board
dead : Board -> Cell -> Bool
dead b c = not <| alive b c


-- get list of neighbor coordinates, bounded by board dimensions --
neighbors : Cell -> Board
neighbors (x, y) =
  map wrap
    [
       (x-1,y-1) , (x  ,y-1)  , (x+1,y-1)
    ,  (x-1,y  ) , {- (x,y) -}  (x+1,y  )
    ,  (x-1,y+1) , (x  ,y+1)  , (x+1,y+1)
    ]


-- wrap a cells coordinates around the edge of the board
wrap : Cell -> Cell
wrap (x, y) =
  (
    toFloat ( ((round (x - 1)) % (round width)) + 1)
  , toFloat ( ((round (y - 1)) % (round height) + 1))
  )


-- Count the number of living neighbors in a cell
livingNeighbors : Board -> Cell -> Int
livingNeighbors b c =
  neighbors c
    |> filter (alive b)
    |> length


-- Evolution Rules
shouldSurvive : Board -> Cell -> Bool
shouldSurvive b c = member (livingNeighbors b c) [2, 3]

shouldBeBorn : Board -> Cell -> Bool
shouldBeBorn b c = (dead b c) && (livingNeighbors b c == 3)


-- filter board by rules
survivors : Board -> Board
survivors b = filter ( shouldSurvive b ) b

births : Board -> Board
births b =
  map neighbors b
    |> concat
    |> removeDuplicates
    |> filter ( shouldBeBorn b )


-- remove duplicate cells generated by finding neighbors
removeDuplicates : Board -> Board
removeDuplicates b =
  case b of
    [] -> []
    x :: xs -> x :: removeDuplicates (filter ((/=) x) xs)


-- evolve state of game
evolve : Board -> Board
evolve b = survivors b ++ births b



-- test board
glider : Board
glider = [(4,2),(2,3),(4,3),(3,4),(4,4)]


background : Overlay
background =
  [0..height]
    |> map (\y -> map (\x -> (x, y)) [0..width])
    |> concat
    |> renderDead


renderCell : Bool -> Cell -> Form
renderCell fill (x,y) =
  square cellSize
    |> filled (if fill then blue else gray)
    |> move
        (
          ((x - width/2)*cellSize)
        , ((y - height/2)*cellSize)
        )


renderAlive : Board -> Overlay
renderAlive b = map (renderCell True) b


renderDead : Board -> Overlay
renderDead b = map (renderCell False) b

render : Board -> Element
render b =
  [background, renderAlive b]
    |> concat
    |> collage (round (cellSize*width)) (round (cellSize*height))


main : Signal Element
main =
  Signal.map view Window.dimensions


view : (Int,Int) -> Element
view (w,h) =
  glider
    |> render
    |> container w h middle
